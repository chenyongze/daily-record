## 高并发解决方案

#### 减少http请求

- css 精灵
  - 注意  x 轴左边  正轴  Y轴   上 正轴
  - 简单点
- 图片地图
  - 标签 `<map><area></area></map>`
- 合并脚本和样式表
- 图片使用base64编码 减少页面请求数



#### 浏览器缓存与数据压缩

#### htttp 缓存机制-分类

- 200 from cache  直接从本地缓存中获取响应

  - 设置本地缓存
    - 设置header 信息
      - Pragma : http 1.0   no-cache 禁用缓存
      - Expires  http 1.0 时代用来启用本地缓存字段  、格林威治时间
      - Cache-Control http1.1 针对 Expires 时间不一致的解决方案 告诉浏览器缓存过期的时间间隔，而不是时刻
        - No-store 禁止浏览器缓存响应
        - No-cache  不允许直接使用本地缓存，先发起请求和服务器协商
        - max-age=delta-seconds : 告知浏览器该响应本地缓存有效的最长期限，以秒未单位
      - 优先级  pragma > cache-control > Expires
    - 适合本地缓存
      - 不变图片
      - js、css 静态文件
      - 可下载内容

- 304 not modified 协商缓存

  - 定义：当浏览器没有命中本地缓存，如本地缓存过期或者响应中声明不允许直接使用本地缓存，那么浏览器肯定会发起服务端请求，服务器会验证数据是否修改，如果没有，浏览器直接使用本地缓存
  - 设置header 信息
    - 响应 Last-Modified : 通知浏览器资源的最后修改时间，格式，格林威治时间，通过 If-Modified-since 提交给服务器做检查
    - 响应  ETag  http 1.1 推出 ，文件指纹标识符，如果文件内容修改，指纹会改变，If-None-Match: 本地缓存失效，会携带此值去请求服务器，服务器端判断该资源是否改变，如果没有改变，直接使用本地缓存。返回304 http 状态
-  适合协商缓存
    - html文件
    - 经常替换图片
    - 经常修改js、css 文件
    - js、css 文件的加载可以加入文件签名来拒绝缓存

##### 不建议缓存内容

- ​	用户隐私等敏感数据
- ​	经常改变的api数据接口



##### Nginx 配置缓存策略

##### 本地缓存配置

- add_header指令 ：添加状态码为 2xx 和 3xx 的响应头信息  add_header name value [always ];
- 可以设置 pragma / expires/cache-control ,可以继承
- Expires  time;  为负值时 表示 cache-control: no-cache;

协商缓存

- Etag 指令： 指定签名；etag on|off; 默认是 on;

#### 资源压缩

- nignx gzip 压缩    gzip on;   gzip_buffer 32 4k| 16 8k; 缓存  (在内存中缓存几块？每块多大？)  gzip_comp_level [1-9] ;推荐6  压缩级别（级别越高、压的越小，越浪费cup计算资源）； gzip_vary on|off ; 是否传输gzip压缩标志
- Js 空白、换行字符压缩，减少文件字符 uglifyJs ..
- css 压缩  原理;去除空白符、注释并且优化一些css语义规则等；工具  css Compressor 
- Html 代码压缩
- 图片压缩  工具： tinypng 、jpegMini、imageOptim

#### cdn加速

- 什么是cdn:    content delivery notwork 即内容分发网络，尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快，更稳定；在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络
- 工作原理：
- 使用场景： 静态资源   css,js,图片,html ，大文件下载
- 实现：

#### 独立图片服务器部署

- 必要性： 分担web服务器I/o负载、能专门对图片服务器进行优化【cup计算能力要求不高】、扩展性可用性提高
- 尽力使用 独立域名,同一域名下，浏览器的并发连接数有限制，突破浏览器连接数的限制【同域名6个连接数】
- 如何进行图片上传和图片同步： NFS共享方式、利用FTP同步

#### 动态语言静态化

- 概念: 将现有的动态脚本语言的逻辑代码生成为静态html文件，用户访问动态脚本重定向到静态html过程。
- 工作原理：域名-》dns服务器解析-》ip->正式服务器-》NGINX-》反向代理fpm->解析html;
- 注意： 对实时性要求不高的页面
- 原因： 动态脚本通常 会做 逻辑计算和数据查询，访问量越大，服务器压力越大；访问量大时可能cpu负载高，数据库压力大；
- 实现方式： smarty 模板引擎  ；cache_dir  缓存目录，caching 是否开启缓存，cache_lifetime 缓存时间，display ,clear_all_cache 清除所有缓存  ，clear_cache  ；
  - smarty 重要技术 ob 系列函数
    - ob_start() 打开输出控制缓冲
    - ob_get_contents() 返回输出缓冲区内容
    - ob_clean() 清空输出缓冲区
    - ob_end_flush() 冲刷出（送出）输出缓冲区内容并关闭缓冲
    - 可以通过判断文件的 inode修改时间，判断是否过期，使用 filectime 函数

####  动态语言的并发处理

##### 什么是 进程、线程、协程

- 进程 （process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础；   进程是一个 “执行中的程序”
  - 进程的三态模型： 多道程序系统中，进程在处理器上交替运行，状态不断地发生变化； 运行、就绪、阻塞；
  - 进程的五态模型：对于一个实际的系统，进程的状态以其转换更为复杂；新建态、活跃就绪/静止就绪、运行、活跃阻塞/静止阻塞、终止态
- 线程：有时被称为轻量级进程（Lightweight Process ，LWP）,是程序执行流的最小单位。   
  - 一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。
  - 线程是程序中一个单一的顺序控制流程。
  - 是进程的可调度的执行单位
  - 在单个程序中同时运行多个线程完成不同的工作，称为多线程
  - 线程的状态：运行、就绪、阻塞
- 协程：协程是一种用户态的轻量级线程，协调的调度完全由用户控制。

- 多进程： 同一个时间里，同一个计算机系统中如果允许两个或者两个以上的进程处于运行状态，这就是多进程
- 多个线程：线程就是把一个进程分为很多片，每一片都可以是一个独立的流程与多进程的区别是只会使用一个进程的资源，线程间可以直接通信
- 异步非阻塞：
  - epoll 实现
  - 老系统 select ，一个系统   1024链接  循环检测
  - 现在各种高并发异步io 的服务器程序都是基于epoll实现的
  - IO复用异步非阻塞程序使用经典的Reactor模型，Reactor 顾名思义就是反应堆的意思，它本身不处理任何数据收发，只是可以监视一个socket句柄的时间变化。
    - Reactor 模型  核心四部
      - add 添加一个scoket 到reactor
      - set
      - del
      - callback
    - nginx:  多线程Reactor
    - Swoole: 多线程Reactor + 多进程 Worker

##### php并发编程实践

- Php 的Swoole扩展
  - 异步操作
  - 
- 消息队列
  - 应用解耦
  - 流量削峰
  - 日志处理【行为日志、错误日志】
  - 消息通讯
  - 常见消息队列产品：
    - kafka
    - activeMq
    - rebbitmq
    - redis
- 接口的并发请求
  - Php curl_mutil_init 

#### 数据库缓存

mysql等一些常见的关系型数据库是存储在磁盘当中

常用的缓存形式：内存缓存，文件缓存

Mysql 自带的查询缓存

- Query_cache_type   0,1,2 三个取值
- SQL_CACHE 
- Query_cache_size 表示查询缓存预留的内存xx
- flush query cache; 清理缓存内存碎片

#### Memcache缓存数据

- 是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，他能够用来存储各种格式的数据。
- get
- Set(key ,val,exprie)
- delete
- php 扩展  memcache  memcached两套扩展   memcached 更丰富

Reids缓存查询

- 与memcache区别
  - 性能相差不大
  - Reids 支持持久化,(快照【RDB】，aof)，依赖快照进行持久化，aof 增强了可靠性的同时，对性能有所影响
  - Redis 在2.0版本后增加了自己的vm特性,突破物理内存的限制。Memcache 可以修改最大可用内存,采用LRU 算法
  - Redis 依赖客户端来实现分布式读写，Memcache本身没有数据冗余机制
  - Memcache 在并发场景下，用cas 保证一致性，redis事务支持比较弱，只能保证事务中的每个操作连续执行
  - Redis 支持多种数据类型

缓存其他数据

​	session   通过   session_set_save_handler



#### mysql数据库层优化

##### 数据表数据类型优化

- 按需选择数据类型
- tinyint 、smallint、int ,bigint
- Char,varchar,  空间效率更好    
- Enum 场景：固定分类  
- Ip地址的存储   ip2long   整型存储ip地址
- 

##### 索引优化

- 索引不是越多越好，在合适的字段上创建合适的索引，因为索引可能提升我们的查询效率，会减低我们的写操作，索引会占用磁盘空间

- Where 列上创建索引

- 复合索引   前缀原则

- Like 查询%的问题   %在前 索引会失效

- 全表扫描优化   自动放弃索引

- or 条件索引使用情况   or 前有索引   后面列没有索引  索引失效

- 字符串类型索引失效的问题    没有带引号

  

##### Sql语句的优化

- 优化查询过程
  - 使用limit 
  - 返回列不用 *
- 

##### 存储引擎的优化

- Innodb  
  - 优点多
  - 支持事务
  - 使用独立空间
  - 支持外键
  - 使用的是行级锁
- myIsAm

##### 数据表结构设计的优化

- 分区
  - 通过特定的策略对数据表进行物理拆分
  - 
- 分库分表
  - 数据量比较大-需要把活跃的数据给拆分出来
  - 水平拆分  -行级拆分
  - 垂直拆分 -常用列拆分

##### 数据库服务器架构的优化

- 主从复制
  - mysql bingLog 日志
- 读写分离
  - 
- 双主热备
- 负载均衡
  - 通过lvs 的三种基本模式实现负载均衡
  - myCat 数据库中间件实现负载均衡

#### web服务器的负载均衡

- 七层负载均衡的实现

  - 基于url等应用层信息的负载均衡,Nginx的 proxy 是它一个很强大的功能，实现了7层负载均衡
  - nginx 负载均衡
    - 内置策略
      - ip hash 
      - 加权轮询
    - 扩展策略
      - fair策略
      - 通过hash  以nginx 内置的变量为key进行hash
      - 一致性hash   采用了nginx 内置的一致性hash环，支持memcache
    - nginx 配置
      - Upstream xxx{  };
      - Proxy_pass http://xxx;

- 四层负载均衡的实现

  - 通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器
  
- LVS 实现服务器集群负载均衡有三种方式 NAT， DR 和 TUN
  
    
  











